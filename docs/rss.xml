<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>帅b何哥学习Blog</title><link>https://LucumaTreeee.github.io/HaoRan_HE.github.io</link><description>你管的着么？</description><copyright>帅b何哥学习Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/183066579?u=0ec21ed6b9cbcd386fbfda8aeabb87e98f04ed8e&amp;v=4</url><title>avatar</title><link>https://LucumaTreeee.github.io/HaoRan_HE.github.io</link></image><lastBuildDate>Mon, 02 Dec 2024 16:56:04 +0000</lastBuildDate><managingEditor>帅b何哥学习Blog</managingEditor><ttl>60</ttl><webMaster>帅b何哥学习Blog</webMaster><item><title>HAE701E TP Traitement du Signal aléatoire</title><link>https://LucumaTreeee.github.io/HaoRan_HE.github.io/post/HAE701E%20TP%20Traitement%20du%20Signal%20al%C3%A9atoire.html</link><description>## Motivations et objectifs&#13;
On va réaliser le filtrage d’un signal qui n’est pas un simple filtrage linéaire comme on le ferait avec un filtre analogique. Il ne s’agit pas simplement de filtrer des fréquences, mais de détecter des parasites dans l’espace des temps et de les supprimer.&#13;
&#13;
### **I.1 Le signal à corriger**&#13;
Le signal temporel que l’on va corriger est un fichier de musique qui est abîmé : il contient des impulsions indésirables, identifiables à l’oreille comme des 'craquements'. Ce genre de situation se produit pour diverses raisons, par exemple :&#13;
&#13;
- Lorsque l’on écoute un disque vinyle et que l’on entend le crépitement de la pointe ;&#13;
- Lors d’un transfert de données sur un système de communication sans vérification : un bit de signal peut changer aléatoirement, ce qui mène à la présence de pics, à des positions aléatoires, superposés au signal ;&#13;
- De façon similaire, un Compact Disc qui comporte des rayures sur la couche optique peut présenter des changements de bit aléatoires,&#13;
- etc&#13;
&#13;
On obtient alors un signal dégradé, dont on donne une représentation:&#13;
&#13;
![alt text](https://i-blog.csdnimg.cn/direct/b849e66e224e43bfabf2d6651f19e9b7.png)&#13;
&#13;
**L’objectif du TP est de recréer un signal très proche du signal **'signal original'** à partir du signal **'signal dégradé'**. Par souci de simplification, les pics du signal dégradé ont tous une durée d’un seul échantillon.**&#13;
&#13;
&#13;
 A. On donne le fichier son au format WAV sur lequel on va travailler, vous pouvez le télécharger ici :&#13;
 https://dl.eea-fds.umontpellier.fr/PythonM1/HAE701/mat/MusiqueBruit.wav&#13;
 Créez un répertoire de travail dans lequel vous placerez le fichier WAV et les scripts Python à écrire.&#13;
 En utilisant votre casque audio pour ne pas déranger vos voisins, écoutez rapidement le début du fichier&#13;
 WAVàpartir de l’explorateur de fichiers, et constatez que vous entendez les craquements.&#13;
&#13;
 B. Créez un nouveau script python et ajoutez-y le code ci-dessous, qui va vous permettre de charger le&#13;
 fichier et de sortir de premières caractéristiques：&#13;
```python&#13;
import os&#13;
from scipy.io import wavfile&#13;
&#13;
directory = 'C:/Users/HaoRan/Desktop/TPTraitementduSignal'&#13;
wav_files = [f for f in os.listdir(directory) if f.endswith('.wav')]&#13;
&#13;
if wav_files:&#13;
    file_path = os.path.join(directory, wav_files[0])&#13;
    Fs, data = wavfile.read(file_path)&#13;
    print('Frequence d’ echantillonnage {} Nombre d’ echantillons {} Codage des amplitudes en {}'.format(Fs, data.shape[0], data.dtype))&#13;
else:&#13;
    print('No .wav files found in the directory.')&#13;
```&#13;
&#13;
&#13;
Vérifiez avec un premier tracé que vous voyez bien le signal. Profitez en pour constater la présence de pics à différents endroits.&#13;
&#13;
C. Observez les informations obtenues. Déduisez-en quelles doivent être les valeurs maximales et minimales des amplitudes du signal. Vérifiez si votre déduction est possible en calculant, avec Python, le min et le max de l’échantillon.&#13;
&#13;
D. Faites en sorte de normaliser le signal à des amplitudes sur une échelle [−1,1]. Ce nouveau signal sera stocke dans une variable nommée signal_audio.&#13;
&#13;
E. Tracez ensuite la courbe du signal obtenu pour vérifier qu’il est sur la bonne échelle verticale.&#13;
&#13;
&#13;
&#13;
&#13;
。</description><guid isPermaLink="true">https://LucumaTreeee.github.io/HaoRan_HE.github.io/post/HAE701E%20TP%20Traitement%20du%20Signal%20al%C3%A9atoire.html</guid><pubDate>Mon, 02 Dec 2024 16:27:32 +0000</pubDate></item></channel></rss>